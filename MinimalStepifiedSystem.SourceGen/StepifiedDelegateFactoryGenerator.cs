using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace MinimalStepifiedSystem.SourceGen;

[Generator(LanguageNames.CSharp)]
public class StepifiedDelegateFactoryGenerator : IIncrementalGenerator
{
    private const string StepifiedProcessAttribute = nameof(StepifiedProcessAttribute);

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var stepifiedProperties = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: (node, _) => node is PropertyDeclarationSyntax,
                transform: (ctx, _) =>
                {
                    var prop = (PropertyDeclarationSyntax)ctx.Node;
                    var model = ctx.SemanticModel;
                    if (model.GetDeclaredSymbol(prop) is not IPropertySymbol symbol)
                        return null;
                    var attr = symbol.GetAttributes().FirstOrDefault(a => a.AttributeClass?.Name == StepifiedProcessAttribute);
                    return attr != null ? (object)new KeyValuePair<IPropertySymbol, AttributeData>(symbol, attr) : null;
                })
            .Where(x => x != null)
            .Select((x, _) => (KeyValuePair<IPropertySymbol, AttributeData>)x!)
            .Collect();

        var compilationAndProperties = context.CompilationProvider.Combine(stepifiedProperties);

        context.RegisterSourceOutput(compilationAndProperties, (spc, data) =>
        {
            var compilation = data.Left;
            var items = data.Right;
            foreach (var item in items)
            {
                var symbol = item.Key;
                var attr = item.Value;
                if (symbol.Type is not INamedTypeSymbol delegateType || delegateType.DelegateInvokeMethod == null) continue;
                var invoke = delegateType.DelegateInvokeMethod;
                if (invoke.Parameters.Length != 2) continue;
                var contextType = invoke.Parameters[0].Type;
                var tokenType = invoke.Parameters[1].Type;
                var returnType = invoke.ReturnType is INamedTypeSymbol rts && rts.IsGenericType ? rts.TypeArguments[0] : null;
                if (contextType == null || tokenType == null || returnType == null) continue;

                List<INamedTypeSymbol> stepTypes = [];
                if (attr.ConstructorArguments.Length > 0 && attr.ConstructorArguments[0].Values.Length > 0)
                {
                    foreach (var v in attr.ConstructorArguments[0].Values)
                        if (v.Value is INamedTypeSymbol s) stepTypes.Add(s);
                }
                if (attr.NamedArguments.FirstOrDefault(kv => kv.Key == "Steps").Value.Values is { } namedSteps && !namedSteps.IsDefaultOrEmpty)
                {
                    foreach (var v in namedSteps)
                        if (v.Value is INamedTypeSymbol s) stepTypes.Add(s);
                }
                if (stepTypes.Count == 0) continue;

                var containingClass = symbol.ContainingType.Name;
                var propertyName = symbol.Name;
                var uniqueFactoryName = $"{containingClass}_{propertyName}_StepifiedFactory";
                var uniqueHintName = $"{uniqueFactoryName}.g.cs";

                var ns = delegateType.ContainingNamespace.ToDisplayString();
                var delegateName = delegateType.Name;
                var contextTypeName = contextType.ToDisplayString();
                var returnTypeName = returnType.ToDisplayString();
                var stepTypeNames = stepTypes.Select(t => t.ToDisplayString()).ToList();

                var sb = new StringBuilder();
                sb.AppendLine("// <auto-generated/>");
                sb.AppendLine("using System;");
                sb.AppendLine("using System.Threading;");
                sb.AppendLine("using System.Threading.Tasks;");
                sb.AppendLine("using Microsoft.Extensions.DependencyInjection;");
                sb.AppendLine($"namespace {ns}");
                sb.AppendLine("{");
                sb.AppendLine($"    // NOTE: For NativeAOT, ensure all step types are registered in DI!");
                sb.AppendLine($"    public static class {uniqueFactoryName}");
                sb.AppendLine("    {");
                sb.AppendLine($"        public static {delegateName} Create(IServiceProvider provider)");
                sb.AppendLine("        {");
                for (int i = 0; i < stepTypeNames.Count; i++)
                    sb.AppendLine($"            var step{i + 1} = provider.GetRequiredService<{stepTypeNames[i]}>();");
                var nextDelegateType = delegateType.ToDisplayString();
                for (int i = stepTypeNames.Count - 1; i >= 0; i--)
                {
                    var next = (i == stepTypeNames.Count - 1)
                        ? $"({contextTypeName} c, CancellationToken t) => Task.FromResult(({returnTypeName})c)"
                        : $"async ({contextTypeName} c, CancellationToken t) => await step{i + 2}.InvokeAsync(c, next{i + 2}, t)";
                    sb.AppendLine($"                {nextDelegateType} next{i + 1} = {next};");
                }
                sb.AppendLine($"            return async ({contextTypeName} ctx, CancellationToken token) => await step1.InvokeAsync(ctx, next1, token);");
                sb.AppendLine("        }");
                sb.AppendLine("    }");
                sb.AppendLine("}");

                spc.AddSource(uniqueHintName, SourceText.From(sb.ToString(), Encoding.UTF8));
            }
        });
    }
}