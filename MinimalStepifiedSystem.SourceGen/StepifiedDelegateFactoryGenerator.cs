using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace MinimalStepifiedSystem.SourceGen;

[Generator]
public class StepifiedDelegateFactoryGenerator : ISourceGenerator
{
    private const string StepifiedProcessAttribute = nameof(StepifiedProcessAttribute);

    public void Initialize(GeneratorInitializationContext context) { }

    public void Execute(GeneratorExecutionContext context)
    {
        // Find all properties with [StepifiedProcess]
        var stepifiedAttrName = StepifiedProcessAttribute;
        var compilation = context.Compilation;
        var allSyntaxTrees = compilation.SyntaxTrees;
        foreach (var tree in allSyntaxTrees)
        {
            var semanticModel = compilation.GetSemanticModel(tree);
            var root = tree.GetRoot();
            var properties = root.DescendantNodes().OfType<PropertyDeclarationSyntax>();
            foreach (var prop in properties)
            {
                if (semanticModel.GetDeclaredSymbol(prop) is not IPropertySymbol symbol) continue;
                var attr = symbol.GetAttributes().FirstOrDefault(a => a.AttributeClass?.Name == stepifiedAttrName);
                if (attr == null) continue;

                // Get delegate type
                if (symbol.Type is not INamedTypeSymbol delegateType || delegateType.DelegateInvokeMethod == null) continue;
                var invoke = delegateType.DelegateInvokeMethod;
                // Must be Task<TResult>(TContext, CancellationToken)
                if (invoke.Parameters.Length != 2) continue;
                var contextType = invoke.Parameters[0].Type;
                var tokenType = invoke.Parameters[1].Type;
                var returnType = invoke.ReturnType is INamedTypeSymbol rts && rts.IsGenericType ? rts.TypeArguments[0] : null;
                if (contextType == null || tokenType == null || returnType == null) continue;

                // Get steps from attribute (handle both constructor and named argument)
                List<INamedTypeSymbol> stepTypes = [];
                // Constructor argument
                if (attr.ConstructorArguments.Length > 0 && attr.ConstructorArguments[0].Values.Length > 0)
                {
                    foreach (var v in attr.ConstructorArguments[0].Values)
                        if (v.Value is INamedTypeSymbol s) stepTypes.Add(s);
                }
                // Named argument (Steps = ...)
                if (attr.NamedArguments.FirstOrDefault(kv => kv.Key == "Steps").Value.Values is { } namedSteps && !namedSteps.IsDefaultOrEmpty)
                {
                    foreach (var v in namedSteps)
                        if (v.Value is INamedTypeSymbol s) stepTypes.Add(s);
                }
                if (stepTypes.Count == 0) continue;

                // Generate unique factory and file name per property
                var containingClass = symbol.ContainingType.Name;
                var propertyName = symbol.Name;
                var uniqueFactoryName = $"{containingClass}_{propertyName}_StepifiedFactory";
                var uniqueHintName = $"{uniqueFactoryName}.g.cs";

                var ns = delegateType.ContainingNamespace.ToDisplayString();
                var delegateName = delegateType.Name;
                var contextTypeName = contextType.ToDisplayString();
                var returnTypeName = returnType.ToDisplayString();
                var stepTypeNames = stepTypes.Select(t => t.ToDisplayString()).ToList();

                var sb = new StringBuilder();
                sb.AppendLine("// <auto-generated/>");
                sb.AppendLine("using System;");
                sb.AppendLine("using System.Threading;");
                sb.AppendLine("using System.Threading.Tasks;");
                sb.AppendLine("using Microsoft.Extensions.DependencyInjection;");
                sb.AppendLine($"namespace {ns}");
                sb.AppendLine("{");
                sb.AppendLine($"    // NOTE: For NativeAOT, ensure all step types are registered in DI!");
                sb.AppendLine($"    public static class {uniqueFactoryName}");
                sb.AppendLine("    {");
                sb.AppendLine($"        public static {delegateName} Create(IServiceProvider provider)");
                sb.AppendLine("        {");
                for (int i = 0; i < stepTypeNames.Count; i++)
                    sb.AppendLine($"            var step{i + 1} = provider.GetRequiredService<{stepTypeNames[i]}>();");
                var nextDelegateType = delegateType.ToDisplayString();
                for (int i = stepTypeNames.Count - 1; i >= 0; i--)
                {
                    var next = (i == stepTypeNames.Count - 1)
                        ? $"({contextTypeName} c, CancellationToken t) => Task.FromResult(({returnTypeName})c)"
                        : $"async ({contextTypeName} c, CancellationToken t) => await step{i + 2}.InvokeAsync(c, next{i + 2}, t)";
                    sb.AppendLine($"                {nextDelegateType} next{i + 1} = {next};");
                }
                sb.AppendLine($"            return async ({contextTypeName} ctx, CancellationToken token) => await step1.InvokeAsync(ctx, next1, token);");
                sb.AppendLine("        }");
                sb.AppendLine("    }");
                sb.AppendLine("}");

                context.AddSource(uniqueHintName, SourceText.From(sb.ToString(), Encoding.UTF8));
            }
        }
    }
}